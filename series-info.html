<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Series Info - Media App</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="Resources/styles.css">
    <link rel="stylesheet" href="Resources/series.css">
</head>
<body>
    <div class="app-container">
        <!-- ****** START: ADD BACK BUTTON ****** -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const showBackBtn = urlParams.get('anime') === 'true';
            const backBtn = document.getElementById('back-button');
            if (backBtn) {
                backBtn.style.display = showBackBtn ? '' : 'none';
            }
        });
    </script>
        <!-- ****** END: ADD BACK BUTTON ****** -->

        <header class="series-hero-section">
            <button id="back-button" class="back-btn">
                <i class="fas fa-arrow-left"></i>
            </button>
            <div class="series-hero-content">
                <h1 class="series-title-text"></h1>
            </div>
            <div class="hero-overlay"></div>
            
        </header>

        <main class="main-content series-main-content">
            <section class="series-details-section">
                <h2 id="series-main-title-backup" style="display:none; font-size: 1.8em; margin-bottom: 15px;"></h2>
                <div class="series-meta-info">
                    <span id="series-score"></span>
                    <span id="series-year"></span>
                    <span id="series-type"></span>
                    <span id="series-episodes-count"></span>
                    <span id="series-status"></span>
                    <span id="series-rating"></span>
                </div>
                <p id="series-synopsis"></p>
                <div id="series-info-additional">
                    <p><strong>English Title:</strong> <span id="series-title-english"></span></p>
                    <p><strong>Japanese Title:</strong> <span id="series-title-japanese"></span></p>
                    <p><strong>Source:</strong> <span id="series-source"></span></p>
                    <p><strong>Duration:</strong> <span id="series-duration"></span></p>
                </div>
                <div class="series-genres"></div>
                <div class="series-studios"></div>
                <div class="series-producers"></div>
            </section>

            <section class="episode-list-section" id="episode-list-section">
                <h2 class="section-title">Episodes</h2>
                <div class="episode-list" id="episode-list-container"></div>
                <div id="episodes-pagination" class="episodes-pagination">
                    <button id="prev-episodes-btn" style="display:none;">Previous</button>
                    <span id="episodes-page-info"></span>
                    <button id="next-episodes-btn" style="display:none;">Next</button>
                </div>
            </section>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // ****** START: BACK BUTTON LOGIC ******
            const urlParams = new URLSearchParams(window.location.search);
            const isAnime = urlParams.get('anime') === 'true';
            const isManga = urlParams.get('manga') === 'true';
            const isLibrary = urlParams.get('library') === 'true';
            const type = isManga ? 'manga' : 'anime';
            const API_BASE_URL = 'https://arkm20-authapi.hf.space';
            let currentSeriesTitle = '';
            const backButton = document.getElementById('back-button');
            if (backButton) {
                backButton.style.display = (isAnime || isManga || isLibrary) ? '' : 'none';
                backButton.addEventListener('click', () => {
                    if (isLibrary === true) {
                        window.location.href = 'library.html';
                    } else {
                        window.location.href = isManga ? 'manga.html' : 'anime.html';
                    }
                });
            }
            // ****** END: BACK BUTTON LOGIC ******

            const heroSection = document.querySelector('.series-hero-section');
            const seriesTitleTextElement = document.querySelector('.series-title-text');
            const seriesMainTitleBackup = document.getElementById('series-main-title-backup');

            const seriesScoreElement = document.getElementById('series-score');
            const seriesYearElement = document.getElementById('series-year');
            const seriesTypeElement = document.getElementById('series-type');
            const seriesEpisodesCountElement = document.getElementById('series-episodes-count');
            const seriesStatusElement = document.getElementById('series-status');
            const seriesRatingElement = document.getElementById('series-rating');
            const seriesSynopsisElement = document.getElementById('series-synopsis');
            const seriesGenresContainer = document.querySelector('.series-genres');
            const seriesStudiosContainer = document.querySelector('.series-studios');
            const seriesProducersContainer = document.querySelector('.series-producers');

            const seriesTitleEnglishElement = document.getElementById('series-title-english');
            const seriesTitleJapaneseElement = document.getElementById('series-title-japanese');
            const seriesSourceElement = document.getElementById('series-source');
            const seriesDurationElement = document.getElementById('series-duration');

            const episodeListContainer = document.getElementById('episode-list-container');
            const episodesPaginationContainer = document.getElementById('episodes-pagination');

            let currentSeriesId = null;
            let episodesData = [];
            let currentPage = 1;
            const episodesPerPage = 25;

            if( type !== 'anime') {
                const episodeListSection = document.getElementById('episode-list-section');
                if (episodeListSection) {
                    episodeListSection.style.display = 'none'; // Hide episode list section for manga
                }
            }
            function getSeriesIdFromUrl() {
                const params = new URLSearchParams(window.location.search);
                return params.get('id');
            }

            async function fetchSeriesDetails(seriesId) {
                try {
                    const response = await fetch(`https://api.jikan.moe/v4/${type}/${seriesId}/full`);
                    if (!response.ok) throw new Error(`Jikan API error (details): ${response.status} ${response.statusText}`);
                    const data = await response.json();
                    console.log(`Fetched ${type} details:`, data.data);
                    return data.data;
                } catch (error) {
                    console.error(`Failed to fetch ${type} details:`, error);
                    displayError('Could not load series details. Please try again later.');
                }
            }

            async function fetchSeriesEpisodes(seriesId) {
                if (type !== 'anime') return [];
                let allEpisodes = [];
                let page = 1;
                let hasMorePages = true;

                try {
                    while (hasMorePages) {
                        const response = await fetch(`https://api.jikan.moe/v4/anime/${seriesId}/episodes?page=${page}`);
                        if (!response.ok) {
                            if (page === 1) throw new Error(`Jikan API error (episodes): ${response.status} ${response.statusText}`);
                            else {
                                console.warn(`Failed to fetch episode page ${page}: ${response.status}`);
                                hasMorePages = false;
                                break;
                            }
                        }
                        const data = await response.json();
                        if (data.data && data.data.length > 0) {
                            allEpisodes = allEpisodes.concat(data.data);
                        } else {
                            hasMorePages = false;
                        }
                        
                        if (data.pagination && data.pagination.has_next_page) {
                            page++;
                            await new Promise(resolve => setTimeout(resolve, 300));
                        } else {
                            hasMorePages = false;
                        }
                    }
                    return allEpisodes;
                } catch (error) {
                    console.error("Failed to fetch anime episodes:", error);
                    episodeListContainer.innerHTML = '<p>Could not load episodes.</p>';
                    return [];
                }
            }
        

            /*async function updateWatchHistory(showId, showTitle, seasonNumber, episodeNumber) {
                // Check for the access token in localStorage
                const token = localStorage.getItem('accessToken');

                // If no token exists, the user is not logged in. Do nothing.
                if (!token) {
                    console.log("User is not logged in. Skipping watch history update.");
                    return;
                }

                console.log(`Updating watch history for: ${showId} | ${showTitle} - S${seasonNumber}E${episodeNumber}`);

                try {
                    // The API endpoint expects a specific JSON structure in the body
                    const body = {
                        show_id: String(showId),
                        show_title: String(showTitle),
                        season_number: Number(seasonNumber),
                        episode_number: Number(episodeNumber)
                    };

                    console.log("Watch history body:", body);

                    const response = await fetch(`${API_BASE_URL}/users/me/watch-history`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}` // Include the user's token
                        },
                        body: JSON.stringify(body)
                    });

                    console.log("Watch history update response status:", response.status);

                    // We don't need to wait for the response, but it's good practice to log the result for debugging.
                    if (response.ok) {
                        console.log("Watch history updated successfully.");
                    } else {
                        const errorData = await response.json();
                        console.error("Failed to update watch history:", errorData.detail || response.statusText);
                    }
                } catch (error) {
                    console.error("Network error while updating watch history:", error);
                }
            }

            // SNIPPET 2: Place this function inside the DOMContentLoaded listener.

            async function updateWatchHistory(showId, showTitle, seasonNumber, episodeNumber) {
                const token = localStorage.getItem('accessToken');
                console.log("Access token:", token);
                if (!token) {
                    console.log("User not logged in. Skipping watch history update.");
                    // You might want to prompt the user to log in here.
                    // For example: alert("Please log in to save your watch history.");
                    return;
                }

                console.log(`Updating watch history for: ${showId} - ${showTitle} - S${seasonNumber}E${episodeNumber}`);

                try {
                    const params = new URLSearchParams({
                        show_id: String(showId),
                        show_title: String(showTitle),
                        season_number: Number(seasonNumber),
                        episode_number: Number(episodeNumber)
                    });

                    const url = `https://arkm20-authapi.hf.space/users/me/watch-history?${params.toString()}`;

                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    if (response.ok) {
                        const result = await response.json();
                        console.log("Watch history update successful:", result.message);
                    } else {
                        // Specifically check for the authentication error code
                        if (response.status === 401) {
                            console.error("Authentication failed. The token is likely expired or invalid.");
                            // This is a great place to redirect the user to a login page
                            // or show a "Your session has expired, please log in again" message.
                            // For example:
                            // localStorage.removeItem('accessToken'); // Clear the bad token
                            // window.location.href = '/login.html'; // Redirect to login
                        }

                        // Handle other potential errors (like 404 Not Found, 500 Server Error)
                        const errorData = await response.json();
                        console.error(`Failed to update watch history (${response.status}):`, errorData.detail || response.statusText);
                    }
                } catch (error) {
                    console.error("Network error while updating watch history:", error);
                }
            }*/

            function displayAnimeDetails(anime) {
                if (!anime) return;

                const heroImageUrl = anime.images?.jpg?.large_image_url || anime.images?.jpg?.image_url || 'https://placehold.co/1200x700/1A2B3C/FFF?text=No+Image+Available';
                heroSection.style.backgroundImage = `url('${heroImageUrl}')`;

                const displayTitle = anime.title_english || anime.title;
                currentSeriesTitle = displayTitle;
                seriesTitleTextElement.textContent = displayTitle;
                seriesMainTitleBackup.textContent = displayTitle;
                document.title = `${displayTitle} - Series Info`;

                seriesScoreElement.textContent = anime.score ? `Score: ${anime.score}/10 (${anime.scored_by?.toLocaleString() || 0} users)` : 'N/A';
                seriesYearElement.textContent = `Year: ${anime.year || (anime.aired?.prop?.from?.year || 'N/A')}`;
                seriesTypeElement.textContent = `Type: ${anime.type || 'N/A'}`;
                seriesEpisodesCountElement.textContent = `Episodes: ${anime.episodes || 'N/A'}`;
                seriesStatusElement.textContent = `Status: ${anime.status || 'N/A'}`;
                seriesRatingElement.textContent = `Rating: ${anime.rating || 'N/A'}`;
                
                seriesSynopsisElement.innerHTML = anime.synopsis ? anime.synopsis.replace(/\n/g, '<br>') : 'No synopsis available.';

                seriesTitleEnglishElement.textContent = anime.title_english || 'N/A';
                seriesTitleJapaneseElement.textContent = anime.title_japanese || 'N/A';
                seriesSourceElement.textContent = anime.source || 'N/A';
                seriesDurationElement.textContent = anime.duration || 'N/A';

                seriesGenresContainer.innerHTML = '<strong>Genres:</strong> ';
                [...anime.genres, ...anime.explicit_genres || [], ...anime.themes || [], ...anime.demographics || []].forEach(g => {
                    const genreSpan = document.createElement('span');
                    genreSpan.textContent = g.name;
                    seriesGenresContainer.appendChild(genreSpan);
                });
                
                seriesStudiosContainer.innerHTML = '<strong>Studios:</strong> ';
                anime.studios.forEach(s => {
                    const studioSpan = document.createElement('span');
                    studioSpan.textContent = s.name;
                    seriesStudiosContainer.appendChild(studioSpan);
                });

                seriesProducersContainer.innerHTML = '<strong>Producers:</strong> ';
                anime.producers.forEach(p => {
                    const producerSpan = document.createElement('span');
                    producerSpan.textContent = p.name;
                    seriesProducersContainer.appendChild(producerSpan);
                });
            }

            function displayEpisodes(episodes) {
                episodeListContainer.innerHTML = '';
                if (!episodes || episodes.length === 0) {
                    episodeListContainer.innerHTML = '<p>No episodes found for this series or they are still loading.</p>';
                    episodesPaginationContainer.innerHTML = '';
                    return;
                }
                episodesData = episodes;
                currentPage = 1;
                renderEpisodePage();
                setupPagination(episodesData.length);
            }


            function renderEpisodePage() {
                episodeListContainer.innerHTML = '';
                const start = (currentPage - 1) * episodesPerPage;
                const end = start + episodesPerPage;
                const paginatedEpisodes = episodesData.slice(start, end);

                paginatedEpisodes.forEach((episode) => {
                    const episodeItem = document.createElement('div');
                    episodeItem.classList.add('episode-item');

                    const episodeNumberSpan = document.createElement('span');
                    episodeNumberSpan.classList.add('episode-number');
                    episodeNumberSpan.textContent = episode.mal_id; // Jikan's episode.mal_id is the episode number

                    const episodeInfoDiv = document.createElement('div');
                    episodeInfoDiv.classList.add('episode-info');

                    const episodeTitle = document.createElement('h4');
                    episodeTitle.classList.add('episode-title');
                    episodeTitle.textContent = episode.title || `Episode ${episode.mal_id}`;

                    const episodeTitleRomanji = document.createElement('p');
                    episodeTitleRomanji.classList.add('episode-title-romanji');
                    episodeTitleRomanji.textContent = episode.title_romanji || '';
                    
                    episodeInfoDiv.appendChild(episodeTitle);
                    if(episode.title_romanji && episode.title_romanji !== episode.title) {
                        episodeInfoDiv.appendChild(episodeTitleRomanji);
                    }
                    
                    episodeItem.appendChild(episodeNumberSpan);
                    episodeItem.appendChild(episodeInfoDiv);
                    episodeItem.addEventListener('click', () => {
                        console.log(`Navigating to episode ${episode.mal_id} of ${currentSeriesTitle} -> ${currentSeriesId}`);
                        /*updateWatchHistory(
                            currentSeriesId,        // The ID of the show, already stored
                            currentSeriesTitle,     // The title of the show, which we now store
                            1,                      // Assumed Season Number
                            episode.mal_id          // The episode number from the Jikan object
                        );*/

                        // --- YOUR ORIGINAL NAVIGATION LOGIC (RUNS IMMEDIATELY) ---
                        // The user is navigated away without waiting for the API call to finish.
                        const url = `view.html?id=${encodeURIComponent(currentSeriesId)}&ep=${encodeURIComponent(episode.mal_id)}`;
                        window.location.href = url;
                    });

                    episodeListContainer.appendChild(episodeItem);
                });
            }

            function setupPagination(totalEpisodes) {
                episodesPaginationContainer.innerHTML = ''; // Clear previous pagination
                const pageCount = Math.ceil(totalEpisodes / episodesPerPage);

                if (pageCount <= 1) return;

                const prevButton = document.createElement('button');
                prevButton.innerHTML = '« Prev';
                prevButton.disabled = currentPage === 1;
                prevButton.addEventListener('click', () => {
                    if (currentPage > 1) {
                        currentPage--;
                        renderEpisodePage();
                        updatePaginationButtons(pageCount);
                    }
                });
                episodesPaginationContainer.appendChild(prevButton);

                const pageInfo = document.createElement('span');
                pageInfo.textContent = ` Page ${currentPage} of ${pageCount} `;
                pageInfo.style.margin = "0 10px";
                episodesPaginationContainer.appendChild(pageInfo);

                const nextButton = document.createElement('button');
                nextButton.innerHTML = 'Next »';
                nextButton.disabled = currentPage === pageCount;
                nextButton.addEventListener('click', () => {
                    if (currentPage < pageCount) {
                        currentPage++;
                        renderEpisodePage();
                        updatePaginationButtons(pageCount);
                    }
                });
                episodesPaginationContainer.appendChild(nextButton);
            }

            function updatePaginationButtons(pageCount) {
                const prevButton = episodesPaginationContainer.querySelector('button:first-child');
                const nextButton = episodesPaginationContainer.querySelector('button:last-child');
                const pageInfo = episodesPaginationContainer.querySelector('span');

                if (prevButton) prevButton.disabled = currentPage === 1;
                if (nextButton) nextButton.disabled = currentPage === pageCount;
                if (pageInfo) pageInfo.textContent = ` Page ${currentPage} of ${pageCount} `;
            }

            function displayError(message) {
                const mainContent = document.querySelector('.series-main-content');
                if (mainContent) {
                    mainContent.innerHTML = `<p class="error-message" style="color: #ff6b6b; text-align: center; padding: 30px; font-size: 1.2em;">${message}</p>`;
                }
                if(heroSection) heroSection.style.display = 'none';
                if (backButton && message.includes("No series ID specified")) {
                    backButton.style.display = 'none';
                }
            }

            async function init() {
                currentSeriesId = getSeriesIdFromUrl();
                if (!currentSeriesId) {
                    displayError("No series ID specified in the URL. Example: series-info.html?id=5114");
                    return;
                }

                const seriesDetails = await fetchSeriesDetails(currentSeriesId);
                if (seriesDetails) {
                    displayAnimeDetails(seriesDetails);
                    if (type === 'anime') {
                        const episodes = await fetchSeriesEpisodes(currentSeriesId);
                        displayEpisodes(episodes);
                    } else {
                        if (document.querySelector('.episode-list-section')) {
                            document.querySelector('.episode-list-section').style.display = 'none';
                        }
                    }
                } else {
                     if(heroSection) heroSection.style.display = 'none';
                }
            }

            // ****** EPISODE PAGINATION LOGIC (secondary, potentially conflicting - review if issues arise) ******
            // Declare at top-level only if not already declared
            if (typeof window.episodesDataGlobal === 'undefined') window.episodesDataGlobal = []; // Renamed to avoid conflict
            if (typeof window.currentEpisodesPageGlobal === 'undefined') window.currentEpisodesPageGlobal = 1; // Renamed
            const EPISODES_PER_PAGE_GLOBAL = 10; // Renamed

            function renderEpisodesPageGlobal(page) { // Renamed
                const episodeListContainerGlobal = document.getElementById('episode-list-container'); // This targets the same container
                const pageInfoGlobal = document.getElementById('episodes-page-info');
                const prevBtnGlobal = document.getElementById('prev-episodes-btn');
                const nextBtnGlobal = document.getElementById('next-episodes-btn');
                
                // This logic might conflict with the primary pagination.
                // For now, it's left as is but commented out the direct manipulation if it's not the primary one.
                // If this section is intended to be the main pagination, it should be integrated properly.
                /*
                if (!window.episodesDataGlobal || window.episodesDataGlobal.length === 0) {
                    episodeListContainerGlobal.innerHTML = '<p>No episodes found.</p>'; // Might overwrite primary render
                    if(pageInfoGlobal) pageInfoGlobal.textContent = '';
                    if(prevBtnGlobal) prevBtnGlobal.style.display = 'none';
                    if(nextBtnGlobal) nextBtnGlobal.style.display = 'none';
                    return;
                }
                const totalPages = Math.ceil(window.episodesDataGlobal.length / EPISODES_PER_PAGE_GLOBAL);
                page = Math.max(1, Math.min(page, totalPages));
                window.currentEpisodesPageGlobal = page;
                const start = (page - 1) * EPISODES_PER_PAGE_GLOBAL;
                const end = start + EPISODES_PER_PAGE_GLOBAL;
                const episodesToShow = window.episodesDataGlobal.slice(start, end);
                episodeListContainerGlobal.innerHTML = ''; // Definitely overwrites primary render
                episodesToShow.forEach(ep => {
                    const epDiv = document.createElement('div');
                    epDiv.className = 'episode-item';
                    epDiv.textContent = ep.title || `Episode ${ep.mal_id || ''}`;
                    // Note: This rendering does not include the amvstrm click listener if it takes over.
                    episodeListContainerGlobal.appendChild(epDiv);
                });
                if(pageInfoGlobal) pageInfoGlobal.textContent = `Page ${page} of ${totalPages}`;
                if(prevBtnGlobal) prevBtnGlobal.style.display = page > 1 ? '' : 'none';
                if(nextBtnGlobal) nextBtnGlobal.style.display = page < totalPages ? '' : 'none';
                */
            }
            
            // These listeners are on buttons by ID. If setupPagination clears and recreates buttons
            // without these IDs, these listeners won't work on the new buttons.
            // The `setupPagination` function creates its own buttons and attaches listeners directly.
            // So, these listeners below might be for the initially hidden buttons if they are not replaced.
            const prevEpisodesBtnById = document.getElementById('prev-episodes-btn');
            if (prevEpisodesBtnById) {
                prevEpisodesBtnById.addEventListener('click', () => {
                    // renderEpisodesPageGlobal(window.currentEpisodesPageGlobal - 1);
                    // This might be redundant if setupPagination handles its own buttons.
                });
            }

            const nextEpisodesBtnById = document.getElementById('next-episodes-btn');
            if (nextEpisodesBtnById) {
                nextEpisodesBtnById.addEventListener('click', () => {
                    // renderEpisodesPageGlobal(window.currentEpisodesPageGlobal + 1);
                });
            }

            function setEpisodesGlobal(episodes) { // Renamed
                window.episodesDataGlobal = episodes || [];
                // renderEpisodesPageGlobal(1); // Initial call for the secondary system
            }


            init();
        });
    </script>
</body>
</html>