<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Search - Media App</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="Resources/styles.css">
    <style>
        /* Basic styling for the back button and iframe container */
        #iframe-container {
            width: 100%;
            height: calc(100vh - 60px); /* Adjust height as needed, considering other elements */
            display: flex;
            flex-direction: column;
        }
        #series-info-iframe {
            flex-grow: 1;
            border: none;
        }
        .back-button {
            padding: 10px 15px;
            margin-bottom: 10px;
            background-color: #333;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            display: flex;
            align-items: center;
        }
        .back-button i {
            margin-right: 8px;
        }
        .search-bar-container input {
            flex-grow: 1; /* Allow input to take available space */
        }
        .search-bar-container .fa-search {
            cursor: pointer; /* Make search icon look clickable */
        }
        /* Ensure recent search items are styled correctly */
        .recent-search-item {
            background-color: #2c2c2c; /* Darker background for recent items */
            color: #eee;
            padding: 10px 15px;
            border-radius: 20px; /* Pill shape */
            margin: 5px;
            display: inline-flex; /* Align text and icon */
            align-items: center;
            font-size: 0.9em;
            cursor: pointer;
        }
        .recent-search-item span {
            margin-right: 10px; /* Space between text and delete icon */
        }
        .recent-search-item .fa-times {
            cursor: pointer;
            color: #aaa; /* Lighter color for delete icon */
        }
        .recent-search-item .fa-times:hover {
            color: #fff; /* White on hover */
        }
        .item-list#search-item-list.recent-searches-active {
            display: flex;
            flex-wrap: wrap; /* Allow recent items to wrap */
            padding-left: 0; /* Remove default list padding if it's a ul/ol */
        }

        /* Style for search results (card-style) */
        .list-item.card-style {
            display: flex;
            align-items: center;
            background-color: #2a2a2a; /* Card background */
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .list-item.card-style:hover {
            background-color: #3a3a3a;
        }
        .list-item.card-style .item-thumbnail img {
            width: 60px; /* Fixed width for thumbnail */
            height: 80px; /* Fixed height for thumbnail */
            object-fit: cover;
            border-radius: 4px;
            margin-right: 15px;
        }
        .list-item.card-style .item-details {
            flex-grow: 1;
        }
        .list-item.card-style .item-title {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 5px;
        }
        .list-item.card-style .item-meta {
            margin-bottom: 5px;
        }
        .list-item.card-style .meta-pill {
            background-color: #444;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.8em;
            margin-right: 5px;
        }
        .list-item.card-style .item-description {
            font-size: 0.9em;
            color: #ccc;
            /* Limit description lines */
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2; /* Number of lines to show */
            -webkit-box-orient: vertical;
        }
        .list-item.card-style .item-arrow {
            margin-left: 10px;
            color: #888;
        }
        #episodes-pagination {
            margin-top: 25px;
            text-align: center;
        }

        #episodes-pagination button {
            background-color: #333;
            color: white;
            border: none;
            padding: 10px 18px;
            margin: 0 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            font-size: 0.9em;
        }

        #episodes-pagination button:hover:not(:disabled) {
            background-color: var(--accent-color-active); /* Netflix red for hover */
        }

        #episodes-pagination button:disabled {
            background-color: #202020;
            color: #555;
            cursor: not-allowed;
        }
        #episodes-pagination span {
            color: #aaa;
            font-size: 0.9em;
        }

        /* Pagination styles for search pagination (matches episode pagination) */
        .pagination-container {
            margin-top: 25px;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .pagination-btn {
            background-color: #333;
            color: white;
            border: none;
            padding: 10px 18px;
            margin: 0 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            font-size: 0.9em;
        }
        .pagination-btn:hover:not(:disabled) {
            background-color: var(--accent-color-active);
        }
        .pagination-btn:disabled {
            background-color: #202020;
            color: #555;
            cursor: not-allowed;
        }
        .pagination-container span {
            color: #aaa;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <main class="main-content no-hero">
            <section id="search-interaction-area">
                <div class="search-bar-container">
                    <input type="text" id="search-input" placeholder="Type to Search Anime...">
                    <i class="fas fa-search" id="search-icon"></i>
                </div>

                <div id="search-content-area">
                    <h2 class="section-title" id="results-title">Recents</h2>
                    <div class="item-list" id="search-item-list">
                        <!-- Recent searches or results will be populated here -->
                    </div>
                </div>
            </section>

            <section id="iframe-container" style="display: none;">
                <button id="back-to-search-btn" class="back-button">
                    <i class="fas fa-arrow-left"></i> Back to Search
                </button>
                <iframe id="series-info-iframe" title="Series Information"></iframe>
            </section>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const searchInput = document.getElementById('search-input');
            const searchIcon = document.getElementById('search-icon');
            const searchItemList = document.getElementById('search-item-list');
            const resultsTitle = document.getElementById('results-title');
            const searchInteractionArea = document.getElementById('search-interaction-area');
            const iframeContainer = document.getElementById('iframe-container');
            const seriesInfoIframe = document.getElementById('series-info-iframe');
            const backToSearchBtn = document.getElementById('back-to-search-btn');
            // const searchContentArea = document.getElementById('search-content-area'); // Not explicitly used in this scope, can be removed if not needed elsewhere

            const RECENT_SEARCHES_KEY = 'animeRecentSearches';
            const MAX_RECENT_SEARCHES = 5;

            let allSearchResults = [];
            let currentSearchPage = 1;
            const resultsPerPage = 10;
            
            // --- Recent Searches Functions ---
            function getRecentSearches() {
                const searches = localStorage.getItem(RECENT_SEARCHES_KEY);
                return searches ? JSON.parse(searches) : [];
            }

            function addRecentSearch(term) {
                if (!term || term.trim() === '') return;
                let searches = getRecentSearches();
                // Remove existing term to add it to the top (most recent)
                searches = searches.filter(s => s.toLowerCase() !== term.toLowerCase());
                searches.unshift(term); // Add to the beginning
                if (searches.length > MAX_RECENT_SEARCHES) {
                    searches = searches.slice(0, MAX_RECENT_SEARCHES);
                }
                localStorage.setItem(RECENT_SEARCHES_KEY, JSON.stringify(searches));
                // DO NOT call displayRecentSearches() here.
                // The visual list of recents will update when displayRecentSearches() is called
                // (e.g., when input is cleared or on page load).
            }

            function removeRecentSearch(termToRemove) {
                let searches = getRecentSearches();
                searches = searches.filter(s => s.toLowerCase() !== termToRemove.toLowerCase());
                localStorage.setItem(RECENT_SEARCHES_KEY, JSON.stringify(searches));
                displayRecentSearches(); // Refresh the list after removal
            }

            function displayRecentSearches() {
                const searches = getRecentSearches();
                searchItemList.innerHTML = ''; // Clear current items
                searchItemList.classList.add('recent-searches-active'); // Add class for styling flex wrap

                if (searches.length === 0) {
                    resultsTitle.textContent = 'Recents';
                    searchItemList.innerHTML = '<p style="width: 100%; text-align: center;">No recent searches.</p>'; // Added some styling for better presentation
                    return;
                }
                
                resultsTitle.textContent = 'Recents';
                searches.forEach(term => {
                    const recentItem = document.createElement('div');
                    recentItem.classList.add('recent-search-item');
                    
                    const termSpan = document.createElement('span');
                    termSpan.textContent = term;
                    termSpan.addEventListener('click', () => {
                        searchInput.value = term;
                        performSearch(term);
                    });

                    const removeIcon = document.createElement('i');
                    removeIcon.classList.add('fas', 'fa-times');
                    removeIcon.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent term click event (which would trigger a search)
                        removeRecentSearch(term);
                    });

                    recentItem.appendChild(termSpan);
                    recentItem.appendChild(removeIcon);
                    searchItemList.appendChild(recentItem);
                });
            }

            // --- Search Results Functions ---
            async function performSearch(query) {
                if (!query || query.trim() === '') {
                    displayRecentSearches(); // Show recents if query is empty
                    return;
                }

                resultsTitle.textContent = `Results for "${query}"`;
                searchItemList.innerHTML = '<p style="width: 100%; text-align: center;">Loading...</p>'; // Loading indicator
                searchItemList.classList.remove('recent-searches-active');


                try {
                    const response = await fetch(`https://api.jikan.moe/v4/anime?q=${encodeURIComponent(query)}&limit=15`);
                    if (!response.ok) {
                        // Attempt to parse error from Jikan if possible
                        let errorMsg = `Jikan API error: ${response.status} ${response.statusText}`;
                        try {
                            const errorData = await response.json();
                            if(errorData && errorData.message) {
                                errorMsg += ` - ${errorData.message}`;
                            }
                        } catch (e) { /* ignore parsing error */ }
                        throw new Error(errorMsg);
                    }
                    const data = await response.json();
                    displaySearchResults(data.data, query); // Pass query for context if needed
                    if (data.data && data.data.length > 0) {
                         addRecentSearch(query); // Add to recents (storage only) if search yields results
                    }
                } catch (error) {
                    console.error("Failed to fetch search results:", error);
                    searchItemList.innerHTML = `<p style="width: 100%; text-align: center; color: red;">Error loading results: ${error.message}. Please try again.</p>`;
                    resultsTitle.textContent = `Results for "${query}"`; // Keep the title reflecting the attempted search
                }
            }

            // Pagination controls
            function renderSearchPagination() {
                let paginationDiv = document.getElementById('search-pagination');
                if (!paginationDiv) {
                    paginationDiv = document.createElement('div');
                    paginationDiv.id = 'search-pagination';
                    paginationDiv.className = 'pagination-container'; // Add class for styling
                    paginationDiv.style.display = 'flex';
                    paginationDiv.style.justifyContent = 'center';
                    paginationDiv.style.alignItems = 'center';
                    paginationDiv.style.margin = '20px 0 0 0';
                    searchItemList.parentNode.appendChild(paginationDiv);
                }
                paginationDiv.innerHTML = '';
                if (!allSearchResults || allSearchResults.length <= resultsPerPage) {
                    paginationDiv.style.display = 'none';
                    return;
                }
                paginationDiv.style.display = 'flex';
                const totalPages = Math.ceil(allSearchResults.length / resultsPerPage);
                const prevBtn = document.createElement('button');
                prevBtn.textContent = 'Prev';
                prevBtn.disabled = currentSearchPage === 1;
                prevBtn.className = 'pagination-btn'; // Add class for styling
                prevBtn.style.marginRight = '10px';
                prevBtn.addEventListener('click', () => {
                    if (currentSearchPage > 1) {
                        currentSearchPage--;
                        renderSearchResultsPage();
                    }
                });
                const nextBtn = document.createElement('button');
                nextBtn.textContent = 'Next';
                nextBtn.disabled = currentSearchPage === totalPages;
                nextBtn.className = 'pagination-btn'; // Add class for styling
                nextBtn.style.marginLeft = '10px';
                nextBtn.addEventListener('click', () => {
                    if (currentSearchPage < totalPages) {
                        currentSearchPage++;
                        renderSearchResultsPage();
                    }
                });
                const pageInfo = document.createElement('span');
                pageInfo.textContent = ` Page ${currentSearchPage} of ${totalPages} `;
                pageInfo.style.margin = '0 10px';
                paginationDiv.appendChild(prevBtn);
                paginationDiv.appendChild(pageInfo);
                paginationDiv.appendChild(nextBtn);
            }

            function renderSearchResultsPage() {
                if (!allSearchResults || allSearchResults.length === 0) return;
                const start = (currentSearchPage - 1) * resultsPerPage;
                const end = start + resultsPerPage;
                const pageResults = allSearchResults.slice(start, end);
                // Reuse displaySearchResults logic, but with only the pageResults
                searchItemList.innerHTML = '';
                searchItemList.classList.remove('recent-searches-active');
                pageResults.forEach(anime => {
                    const listItem = document.createElement('div');
                    listItem.classList.add('list-item', 'card-style');
                    listItem.addEventListener('click', () => {
                        showSeriesInfo(anime.mal_id);
                    });
                    const thumbnailDiv = document.createElement('div');
                    thumbnailDiv.classList.add('item-thumbnail');
                    const thumbnailImg = document.createElement('img');
                    thumbnailImg.src = anime.images?.jpg?.image_url || 'https://placehold.co/60x80/444/fff?text=N/A';
                    thumbnailImg.alt = anime.title_english || anime.title;
                    thumbnailDiv.appendChild(thumbnailImg);
                    const detailsDiv = document.createElement('div');
                    detailsDiv.classList.add('item-details');
                    const titleH3 = document.createElement('h3');
                    titleH3.classList.add('item-title');
                    titleH3.textContent = anime.title_english || anime.title;
                    detailsDiv.appendChild(titleH3);
                    const metaDiv = document.createElement('div');
                    metaDiv.classList.add('item-meta');
                    if (anime.score) {
                        const scoreSpan = document.createElement('span');
                        scoreSpan.classList.add('meta-pill');
                        scoreSpan.textContent = `${anime.score}/10`;
                        metaDiv.appendChild(scoreSpan);
                    }
                    if (anime.episodes) {
                        const episodesSpan = document.createElement('span');
                        episodesSpan.classList.add('meta-pill');
                        episodesSpan.textContent = `${anime.episodes} EP`;
                        metaDiv.appendChild(episodesSpan);
                    }
                    detailsDiv.appendChild(metaDiv);
                    const descriptionP = document.createElement('p');
                    descriptionP.classList.add('item-description');
                    const synopsis = anime.synopsis || 'No description available.';
                    descriptionP.textContent = synopsis.length > 100 ? synopsis.substring(0, 100) + '...' : synopsis;
                    detailsDiv.appendChild(descriptionP);
                    const arrowDiv = document.createElement('div');
                    arrowDiv.classList.add('item-arrow');
                    const arrowIcon = document.createElement('i');
                    arrowIcon.classList.add('fas', 'fa-chevron-right');
                    arrowDiv.appendChild(arrowIcon);
                    listItem.appendChild(thumbnailDiv);
                    listItem.appendChild(detailsDiv);
                    listItem.appendChild(arrowDiv);
                    searchItemList.appendChild(listItem);
                });
                renderSearchPagination();
            }

            // Update displaySearchResults to use pagination
            function displaySearchResults(animeData, query) {
                allSearchResults = animeData || [];
                currentSearchPage = 1;
                if (!allSearchResults || allSearchResults.length === 0) {
                    searchItemList.innerHTML = `<p style="width: 100%; text-align: center;">No results found for "${query}".</p>`;
                    resultsTitle.textContent = `Results for "${query}"`;
                    let paginationDiv = document.getElementById('search-pagination');
                    if (paginationDiv) paginationDiv.style.display = 'none';
                    return;
                }
                resultsTitle.textContent = `Results for "${query}"`;
                renderSearchResultsPage();
            }

            // --- Iframe and View Switching Functions ---
            function showSeriesInfo(animeId) {
                seriesInfoIframe.src = `series-info.html?id=${animeId}`;
                searchInteractionArea.style.display = 'none';
                iframeContainer.style.display = 'flex'; 
            }

            function showSearchView() {
                iframeContainer.style.display = 'none';
                searchInteractionArea.style.display = 'block'; 
                seriesInfoIframe.src = 'about:blank'; 
                
                // Decide what to show: last search results or recents
                const currentQuery = searchInput.value.trim();
                if (currentQuery) {
                    // If there's still a query in the input, re-run the search
                    // or you could potentially cache the last results to avoid an API call.
                    // For simplicity, let's just stick to recents if input is empty, or current results.
                    // The performSearch function handles the title and list updates.
                    // performSearch(currentQuery); // This might be too aggressive
                } else {
                    displayRecentSearches(); // Default to recents if search input is now empty
                }
                // No explicit action here to re-display search results if coming back from iframe,
                // as the results should still be in the DOM unless explicitly cleared.
                // If searchInput.value is not empty, performSearch would have already been called 
                // or the results are still there.
            }

            // --- Event Listeners ---
            let searchTimeout;
            searchInput.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    const query = searchInput.value.trim();
                    performSearch(query); // performSearch will call displayRecentSearches if query is empty
                }, 500); 
            });
            
            searchInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    clearTimeout(searchTimeout); 
                    const query = searchInput.value.trim();
                    performSearch(query); // performSearch will call displayRecentSearches if query is empty
                }
            });

            searchIcon.addEventListener('click', () => {
                clearTimeout(searchTimeout);
                const query = searchInput.value.trim();
                performSearch(query); // performSearch will call displayRecentSearches if query is empty
            });

            backToSearchBtn.addEventListener('click', showSearchView);

            // --- Initial Load ---
            displayRecentSearches(); 
        });
    </script>
</body>
</html>